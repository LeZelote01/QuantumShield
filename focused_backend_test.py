#!/usr/bin/env python3
"""
Test cibl√© pour les corrections QuantumShield
Focus sur les endpoints corrig√©s selon la demande de r√©vision
"""

import asyncio
import aiohttp
import json
import os
import sys
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

# Configuration des tests
BACKEND_URL = "http://localhost:8001"
API_BASE = f"{BACKEND_URL}/api"

class FocusedQuantumShieldTester:
    def __init__(self):
        self.session = None
        self.auth_token = None
        self.test_user = {
            "username": "quantum_focused_tester",
            "email": "focused_tester@quantumshield.com",
            "password": "SecurePassword123!"
        }
        self.test_data = {}
        self.corrected_endpoints_results = {}

    async def setup(self):
        """Initialise la session HTTP"""
        self.session = aiohttp.ClientSession()
        print("üîß Session HTTP initialis√©e pour tests cibl√©s")

    async def cleanup(self):
        """Nettoie les ressources"""
        if self.session:
            await self.session.close()
        print("üßπ Nettoyage termin√©")

    async def make_request(self, method: str, endpoint: str, data: Dict = None, 
                          headers: Dict = None, auth_required: bool = False) -> Dict:
        """Effectue une requ√™te HTTP avec gestion d'erreurs"""
        url = f"{API_BASE}{endpoint}"
        
        # Headers par d√©faut
        request_headers = {"Content-Type": "application/json"}
        if headers:
            request_headers.update(headers)
        
        # Ajouter l'authentification si n√©cessaire
        if auth_required and self.auth_token:
            request_headers["Authorization"] = f"Bearer {self.auth_token}"
        
        try:
            if method.upper() == "GET":
                async with self.session.get(url, headers=request_headers) as response:
                    result = await response.json()
                    return {"status": response.status, "data": result}
            elif method.upper() == "POST":
                async with self.session.post(url, json=data, headers=request_headers) as response:
                    result = await response.json()
                    return {"status": response.status, "data": result}
            elif method.upper() == "PUT":
                async with self.session.put(url, json=data, headers=request_headers) as response:
                    result = await response.json()
                    return {"status": response.status, "data": result}
        except Exception as e:
            return {"status": 500, "error": str(e)}

    async def setup_auth(self):
        """Configure l'authentification pour les tests"""
        print("\nüîê Configuration de l'authentification...")
        
        # Enregistrement
        response = await self.make_request("POST", "/auth/register", self.test_user)
        if response["status"] != 200:
            print(f"‚ùå √âchec de l'enregistrement: {response}")
            return False
        
        # Connexion
        login_data = {
            "username": self.test_user["username"],
            "password": self.test_user["password"]
        }
        response = await self.make_request("POST", "/auth/login", login_data)
        if response["status"] == 200 and response["data"].get("token"):
            self.auth_token = response["data"]["token"]
            print("‚úÖ Authentification configur√©e")
            return True
        
        print(f"‚ùå √âchec de la connexion: {response}")
        return False

    async def setup_crypto_keypair(self):
        """Configure une paire de cl√©s pour les tests crypto"""
        print("\nüîë Configuration des cl√©s cryptographiques...")
        
        # G√©n√©ration de paire de cl√©s multi-algorithmes
        keypair_request = {
            "encryption_algorithm": "Kyber-768",
            "signature_algorithm": "Dilithium-3"
        }
        response = await self.make_request("POST", "/advanced-crypto/generate-multi-algorithm-keypair", 
                                         keypair_request, auth_required=True)
        
        if response["status"] == 200 and response["data"].get("keypair"):
            keypair = response["data"]["keypair"]
            self.test_data["advanced_keypair_id"] = keypair.get("keypair_id")
            print(f"‚úÖ Paire de cl√©s g√©n√©r√©e: {keypair.get('keypair_id')}")
            return True
        
        print(f"‚ùå √âchec de g√©n√©ration de cl√©s: {response}")
        return False

    async def test_hybrid_decrypt_correction(self):
        """Test de la correction du d√©chiffrement hybride (√©tait HTTP 500)"""
        print("\nüîì Test Correction: D√©chiffrement Hybride...")
        
        if not self.test_data.get("advanced_keypair_id"):
            print("‚ùå Pas de paire de cl√©s disponible")
            self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "failed", "reason": "no_keypair"}
            return False
        
        try:
            # D'abord chiffrer un message
            encrypt_request = {
                "message": "Test message pour d√©chiffrement hybride corrig√©",
                "keypair_id": self.test_data["advanced_keypair_id"]
            }
            encrypt_response = await self.make_request("POST", "/advanced-crypto/hybrid-encrypt", 
                                                     encrypt_request, auth_required=True)
            
            if encrypt_response["status"] != 200:
                print(f"‚ùå √âchec du chiffrement pr√©alable: {encrypt_response['status']}")
                self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "failed", "reason": "encrypt_failed"}
                return False
            
            encrypted_data = encrypt_response["data"]["encrypted_data"]
            
            # Maintenant tester le d√©chiffrement (endpoint corrig√©)
            decrypt_request = {
                "encrypted_data": encrypted_data,
                "keypair_id": self.test_data["advanced_keypair_id"]
            }
            response = await self.make_request("POST", "/advanced-crypto/hybrid-decrypt", 
                                             decrypt_request, auth_required=True)
            
            if response["status"] == 200:
                data = response["data"]
                if data.get("decrypted_message") and data.get("status") == "success":
                    print("‚úÖ CORRECTION VALID√âE: D√©chiffrement hybride fonctionne")
                    print(f"   Message d√©chiffr√©: {data.get('decrypted_message')}")
                    self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "success", "message": data.get('decrypted_message')}
                    return True
                else:
                    print(f"‚ùå D√©chiffrement √©chou√©: {data}")
                    self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "failed", "reason": "decrypt_logic_failed", "data": data}
            else:
                print(f"‚ùå Erreur HTTP {response['status']} (√©tait 500 avant correction)")
                self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "failed", "reason": f"http_{response['status']}", "data": response.get('data')}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["hybrid_decrypt"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_security_dashboard_correction(self):
        """Test de la correction du dashboard s√©curit√© (√©tait HTTP 500)"""
        print("\nüìä Test Correction: Dashboard S√©curit√©...")
        
        try:
            response = await self.make_request("GET", "/security/dashboard", auth_required=True)
            
            if response["status"] == 200:
                data = response["data"]
                if data.get("dashboard") and data.get("status") == "success":
                    dashboard = data["dashboard"]
                    print("‚úÖ CORRECTION VALID√âE: Dashboard s√©curit√© fonctionne")
                    overview = dashboard.get("overview", {})
                    print(f"   √âv√©nements (24h): {overview.get('events_last_24h', 0)}")
                    print(f"   Alertes actives: {overview.get('active_alerts', 0)}")
                    print(f"   Score s√©curit√©: {dashboard.get('security_score', 0)}")
                    self.corrected_endpoints_results["security_dashboard"] = {"status": "success", "score": dashboard.get('security_score')}
                    return True
                else:
                    print(f"‚ùå Dashboard incomplet: {data}")
                    self.corrected_endpoints_results["security_dashboard"] = {"status": "failed", "reason": "incomplete_data", "data": data}
            else:
                print(f"‚ùå Erreur HTTP {response['status']} (√©tait 500 avant correction)")
                self.corrected_endpoints_results["security_dashboard"] = {"status": "failed", "reason": f"http_{response['status']}", "data": response.get('data')}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["security_dashboard"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_zk_proof_generation_correction(self):
        """Test de la correction de g√©n√©ration ZK-proofs (√©tait HTTP 500)"""
        print("\nüî¨ Test Correction: G√©n√©ration ZK-Proofs...")
        
        try:
            # Test des 4 types de preuves ZK impl√©ment√©es
            proof_types = ["membership", "range", "knowledge", "non_interactive"]
            
            for proof_type in proof_types:
                print(f"   Test preuve {proof_type}...")
                
                zk_request = {
                    "proof_type": proof_type,
                    "statement": f"Test statement for {proof_type} proof",
                    "witness": f"Test witness for {proof_type}",
                    "public_parameters": {"test_param": "value"}
                }
                
                response = await self.make_request("POST", "/advanced-crypto/generate-zk-proof", 
                                                 zk_request, auth_required=True)
                
                if response["status"] == 200:
                    data = response["data"]
                    if data.get("proof_data") and data.get("status") == "success":
                        proof_data = data["proof_data"]
                        print(f"   ‚úÖ Preuve {proof_type} g√©n√©r√©e: {proof_data.get('proof_id')}")
                    else:
                        print(f"   ‚ùå √âchec g√©n√©ration preuve {proof_type}: {data}")
                        self.corrected_endpoints_results["zk_proof_generation"] = {"status": "failed", "reason": f"{proof_type}_failed", "data": data}
                        return False
                else:
                    print(f"   ‚ùå Erreur HTTP {response['status']} pour preuve {proof_type}")
                    self.corrected_endpoints_results["zk_proof_generation"] = {"status": "failed", "reason": f"http_{response['status']}_for_{proof_type}"}
                    return False
            
            print("‚úÖ CORRECTION VALID√âE: G√©n√©ration ZK-proofs fonctionne pour tous les types")
            self.corrected_endpoints_results["zk_proof_generation"] = {"status": "success", "types_tested": proof_types}
            return True
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["zk_proof_generation"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_advanced_blockchain_health_correction(self):
        """Test de la correction du health check blockchain avanc√© (√©tait HTTP 404)"""
        print("\n‚õìÔ∏è Test Correction: Health Check Blockchain Avanc√©...")
        
        try:
            response = await self.make_request("GET", "/advanced-blockchain/health", auth_required=True)
            
            if response["status"] == 200:
                data = response["data"]
                if "service_ready" in data or "status" in data:
                    print("‚úÖ CORRECTION VALID√âE: Health check blockchain avanc√© fonctionne")
                    print(f"   Status: {data.get('status', 'N/A')}")
                    print(f"   Service Ready: {data.get('service_ready', 'N/A')}")
                    self.corrected_endpoints_results["advanced_blockchain_health"] = {"status": "success", "service_status": data.get('status')}
                    return True
                else:
                    print(f"‚ùå R√©ponse incompl√®te: {data}")
                    self.corrected_endpoints_results["advanced_blockchain_health"] = {"status": "failed", "reason": "incomplete_response", "data": data}
            else:
                print(f"‚ùå Erreur HTTP {response['status']} (√©tait 404 avant correction)")
                self.corrected_endpoints_results["advanced_blockchain_health"] = {"status": "failed", "reason": f"http_{response['status']}", "data": response.get('data')}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["advanced_blockchain_health"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_ota_service_correction(self):
        """Test de la correction du service OTA (√©tait non fonctionnel)"""
        print("\nüì° Test Correction: Service OTA...")
        
        try:
            # Test health check OTA
            response = await self.make_request("GET", "/ota/health")
            
            if response["status"] == 200:
                print("‚úÖ CORRECTION VALID√âE: Health check OTA fonctionne")
                print(f"   Status: {response['data'].get('status', 'N/A')}")
                
                # Test statistiques OTA
                stats_response = await self.make_request("GET", "/ota/statistics", auth_required=True)
                if stats_response["status"] == 200:
                    print("‚úÖ Statistiques OTA fonctionnelles")
                    stats = stats_response["data"]
                    print(f"   Firmware total: {stats.get('total_firmware', 0)}")
                    print(f"   Mises √† jour en attente: {stats.get('pending_updates', 0)}")
                    
                    # Test configuration OTA
                    config_response = await self.make_request("GET", "/ota/config", auth_required=True)
                    if config_response["status"] == 200:
                        print("‚úÖ Configuration OTA accessible")
                        self.corrected_endpoints_results["ota_service"] = {"status": "success", "endpoints_working": ["health", "statistics", "config"]}
                        return True
                    else:
                        print(f"‚ùå Configuration OTA √©chou√©e: {config_response['status']}")
                        self.corrected_endpoints_results["ota_service"] = {"status": "partial", "working": ["health", "statistics"], "failed": ["config"]}
                else:
                    print(f"‚ùå Statistiques OTA √©chou√©es: {stats_response['status']}")
                    self.corrected_endpoints_results["ota_service"] = {"status": "partial", "working": ["health"], "failed": ["statistics"]}
            else:
                print(f"‚ùå Health check OTA √©chou√©: {response['status']}")
                self.corrected_endpoints_results["ota_service"] = {"status": "failed", "reason": f"health_check_http_{response['status']}"}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["ota_service"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_governance_improvements(self):
        """Test des am√©liorations de gouvernance blockchain"""
        print("\nüèõÔ∏è Test Am√©liorations: Gouvernance Blockchain...")
        
        try:
            # Test cr√©ation de proposition
            proposal_request = {
                "title": "Test Proposal for Governance Improvement",
                "description": "This is a test proposal to validate governance corrections",
                "proposal_type": "parameter_change",
                "parameters": {
                    "parameter_name": "block_time",
                    "new_value": 15,
                    "current_value": 10
                },
                "voting_period_hours": 168
            }
            
            response = await self.make_request("POST", "/advanced-blockchain/governance/proposals", 
                                             proposal_request, auth_required=True)
            
            if response["status"] == 200:
                data = response["data"]
                if data.get("proposal") and data.get("status") == "success":
                    proposal = data["proposal"]
                    proposal_id = proposal.get("proposal_id")
                    print("‚úÖ AM√âLIORATION VALID√âE: Cr√©ation de proposition fonctionne")
                    print(f"   Proposition ID: {proposal_id}")
                    print(f"   Titre: {proposal.get('title')}")
                    print(f"   Status: {proposal.get('status')}")
                    
                    # Test vote sur la proposition
                    vote_request = {
                        "vote": "yes",
                        "reason": "Test vote for governance validation"
                    }
                    
                    vote_response = await self.make_request("POST", f"/advanced-blockchain/governance/proposals/{proposal_id}/vote", 
                                                          vote_request, auth_required=True)
                    
                    if vote_response["status"] == 200:
                        print("‚úÖ Vote sur proposition fonctionnel")
                        self.corrected_endpoints_results["governance"] = {"status": "success", "proposal_id": proposal_id}
                        return True
                    else:
                        print(f"‚ùå Vote √©chou√©: {vote_response['status']}")
                        self.corrected_endpoints_results["governance"] = {"status": "partial", "proposal_created": True, "vote_failed": True}
                else:
                    print(f"‚ùå Cr√©ation proposition √©chou√©e: {data}")
                    self.corrected_endpoints_results["governance"] = {"status": "failed", "reason": "proposal_creation_failed", "data": data}
            else:
                print(f"‚ùå Erreur HTTP {response['status']} pour cr√©ation proposition")
                self.corrected_endpoints_results["governance"] = {"status": "failed", "reason": f"http_{response['status']}", "data": response.get('data')}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["governance"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def test_staking_improvements(self):
        """Test des am√©liorations de staking"""
        print("\nüí∞ Test Am√©liorations: Staking de Tokens...")
        
        try:
            # Test staking de tokens
            stake_request = {
                "amount": 100.0,
                "validator_id": "auto_create",  # Cr√©ation automatique de validateur
                "lock_period_days": 30
            }
            
            response = await self.make_request("POST", "/advanced-blockchain/consensus/stake", 
                                             stake_request, auth_required=True)
            
            if response["status"] == 200:
                data = response["data"]
                if data.get("stake_result") and data.get("status") == "success":
                    stake_result = data["stake_result"]
                    print("‚úÖ AM√âLIORATION VALID√âE: Staking de tokens fonctionne")
                    print(f"   Montant stak√©: {stake_result.get('amount')}")
                    print(f"   Validateur: {stake_result.get('validator_id')}")
                    print(f"   P√©riode de verrouillage: {stake_result.get('lock_period_days')} jours")
                    print(f"   R√©compenses estim√©es: {stake_result.get('estimated_rewards', 'N/A')}")
                    self.corrected_endpoints_results["staking"] = {"status": "success", "amount": stake_result.get('amount')}
                    return True
                else:
                    print(f"‚ùå Staking √©chou√©: {data}")
                    self.corrected_endpoints_results["staking"] = {"status": "failed", "reason": "staking_logic_failed", "data": data}
            else:
                print(f"‚ùå Erreur HTTP {response['status']} pour staking")
                self.corrected_endpoints_results["staking"] = {"status": "failed", "reason": f"http_{response['status']}", "data": response.get('data')}
        
        except Exception as e:
            print(f"‚ùå Exception: {e}")
            self.corrected_endpoints_results["staking"] = {"status": "failed", "reason": "exception", "error": str(e)}
        
        return False

    async def run_focused_tests(self):
        """Ex√©cute tous les tests cibl√©s sur les corrections"""
        print("üéØ D√âBUT DES TESTS CIBL√âS SUR LES CORRECTIONS QUANTUMSHIELD")
        print("=" * 70)
        
        await self.setup()
        
        # Configuration pr√©alable
        if not await self.setup_auth():
            print("‚ùå Impossible de configurer l'authentification")
            return
        
        if not await self.setup_crypto_keypair():
            print("‚ùå Impossible de configurer les cl√©s crypto")
            return
        
        # Tests des corrections sp√©cifiques
        print("\nüîß TESTS DES CORRECTIONS APPLIQU√âES:")
        print("-" * 50)
        
        await self.test_hybrid_decrypt_correction()
        await self.test_security_dashboard_correction()
        await self.test_zk_proof_generation_correction()
        await self.test_advanced_blockchain_health_correction()
        await self.test_ota_service_correction()
        await self.test_governance_improvements()
        await self.test_staking_improvements()
        
        await self.cleanup()
        
        # Rapport final
        self.print_correction_report()

    def print_correction_report(self):
        """Affiche le rapport des corrections test√©es"""
        print("\n" + "=" * 70)
        print("üìä RAPPORT DES CORRECTIONS TEST√âES")
        print("=" * 70)
        
        total_tests = len(self.corrected_endpoints_results)
        successful_tests = sum(1 for result in self.corrected_endpoints_results.values() if result["status"] == "success")
        partial_tests = sum(1 for result in self.corrected_endpoints_results.values() if result["status"] == "partial")
        failed_tests = sum(1 for result in self.corrected_endpoints_results.values() if result["status"] == "failed")
        
        print(f"üìà TAUX DE R√âUSSITE DES CORRECTIONS: {successful_tests}/{total_tests} ({(successful_tests/total_tests)*100:.1f}%)")
        print(f"‚úÖ Corrections valid√©es: {successful_tests}")
        print(f"‚ö†Ô∏è Corrections partielles: {partial_tests}")
        print(f"‚ùå Corrections √©chou√©es: {failed_tests}")
        
        print("\nüîç D√âTAIL PAR CORRECTION:")
        for endpoint, result in self.corrected_endpoints_results.items():
            status_icon = "‚úÖ" if result["status"] == "success" else "‚ö†Ô∏è" if result["status"] == "partial" else "‚ùå"
            print(f"{status_icon} {endpoint}: {result['status']}")
            if result["status"] == "failed" and "reason" in result:
                print(f"   Raison: {result['reason']}")
        
        print("\nüéØ RECOMMANDATIONS:")
        if successful_tests == total_tests:
            print("‚úÖ Toutes les corrections sont valid√©es et fonctionnelles!")
            print("‚úÖ Le taux de r√©ussite du backend devrait √™tre significativement am√©lior√©")
        elif successful_tests > failed_tests:
            print("‚ö†Ô∏è La majorit√© des corrections fonctionnent, mais quelques probl√®mes persistent")
            print("üîß Concentrer les efforts sur les corrections √©chou√©es")
        else:
            print("‚ùå Plusieurs corrections n√©cessitent encore du travail")
            print("üîß R√©viser l'impl√©mentation des endpoints √©chou√©s")

async def main():
    """Point d'entr√©e principal"""
    tester = FocusedQuantumShieldTester()
    await tester.run_focused_tests()

if __name__ == "__main__":
    asyncio.run(main())